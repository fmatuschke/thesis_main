# %%
from IPython import get_ipython
get_ipython().run_line_magic('matplotlib', 'inline')
from jupyterthemes import jtplot
jtplot.style(theme="onedork", context="notebook", ticks=True, grid=True)

#%%
import numpy as np

import matplotlib.pyplot as plt
import pandas as pd

# from tqdm import tqdm

import helper.circular
import fastpli.io
import fastpli.tools
import fastpli.objects
import fastpli.analysis

import helper.spherical_interpolation

# %%
df_acc = pd.read_pickle(
    "output/sim_120_new/0.125/analysis/cube_2pop_simulation_schilling.pkl")

# %%
radius = 0.5
microscope = "PM"
model = "p"
f0_inc = 0
psi = 0.3
name = "R"
species = "Roden"

sub = (df_acc.radius == radius) & (df_acc.microscope == microscope) & (
    df_acc.species == species) & (df_acc.model == model) & (
        df_acc.psi == psi) & (df_acc.f0_inc == f0_inc)

sub_ref = (df_acc.radius == radius) & (df_acc.microscope == microscope) & (
    df_acc.species == species) & (df_acc.model == model) & (
        df_acc.psi == 0.0) & (df_acc.f0_inc == 0.0)

f1_rot = df_acc[sub].f1_rot.to_numpy(float)
omega = df_acc[sub].omega.to_numpy(float)

# %%
# get points on sphere
phi = []
theta = []
for f1, om in zip(f1_rot, omega):
    v = np.array([np.cos(np.deg2rad(om)), np.sin(np.deg2rad(om)), 0])
    rot_inc = fastpli.tools.rotation.y(-np.deg2rad(f0_inc))
    rot_phi = fastpli.tools.rotation.x(np.deg2rad(f1))
    rot = np.dot(rot_inc, rot_phi)
    v = np.dot(rot, v)
    theta.extend([np.arccos(v[2])])
    phi.extend([np.arctan2(v[1], v[0])])

phi = np.array(phi)
theta = np.array(theta)
data = df_acc[sub][name].to_numpy(float)

# %%
# norm R and R2 to ref
if name != "acc":
    data /= np.mean(df_acc[sub_ref][name].to_numpy(float))

# %%
# # apply symmetry
phi_ = phi.copy()
theta_ = theta.copy()
data_ = data.copy()
# measurement symmetry
phi_ = np.hstack((phi_, -phi_))
theta_ = np.hstack((theta_, theta_))
data_ = np.hstack((data_, data_))
# orientation symmetry
phi_ = np.hstack((phi_, phi_))
theta_ = np.hstack((theta_, np.pi + theta_))
data_ = np.hstack((data_, data_))

x_ = np.multiply(np.cos(phi_), np.sin(theta_))
y_ = np.multiply(np.sin(phi_), np.sin(theta_))
z_ = np.cos(theta_)
phi_ = np.arctan2(y_, x_)
theta_ = np.arccos(z_)

# rm multiple
# phi_, theta_ = helper.spherical_interpolation.remap_spherical(phi_, theta_)
# tmp = np.vstack((np.round(np.rad2deg(phi_), 0), np.round(np.rad2deg(theta_),
#                                                          0), data_))
# tmp = np.unique(tmp, axis=1)
# phi_, theta_, data_ = np.deg2rad(tmp[0, :]), np.deg2rad(tmp[1, :]), tmp[2, :]

# %%
a = np.empty((phi_.size, phi_.size))
a[:] = np.nan
phi__ = []
theta__ = []
data__ = []
for i in range(phi_.size):
    flag = True
    for j in range(i + 1, phi_.size):
        a[i, j] = np.linalg.norm(
            np.array((x_[i] - x_[j], y_[i] - y_[j], z_[i] - z_[j])))

        if a[i, j] < 1e-6:
            print(
                f"({i}, {j}): {a[i, j]:.2f} \t {phi_[i]:.2f}, {theta_[i]:.2f}, \t {phi_[j]:.2f}, {theta_[j]:.2f}"
            )
            flag = False
    if flag:
        phi__.append(phi_[i])
        theta__.append(theta_[i])
        data__.append(data_[i])

phi__ = np.array(phi__)
theta__ = np.array(theta__)
data__ = np.array(data__)
print(phi_.size, phi__.size)
phi_ = phi__
theta_ = theta__
data_ = data__
# %%

# interplate mesh on sphere
x_i, y_i, z_i, data_i = helper.spherical_interpolation.on_mesh(
    phi_, theta_, data_, 20, 20)

r = 1.05
x = np.multiply(np.cos(phi), np.sin(theta)) * r
y = np.multiply(np.sin(phi), np.sin(theta)) * r
z = np.cos(theta) * r
x_ = np.multiply(np.cos(phi_), np.sin(theta_)) * r
y_ = np.multiply(np.sin(phi_), np.sin(theta_)) * r
z_ = np.cos(theta_) * r

# %%

fig = plt.figure()  # figsize=(10, 10)
ax = fig.add_subplot(111, projection='3d')

ax.plot_surface(x_i, y_i, z_i, facecolors=plt.cm.viridis(data_i))
sc = ax.scatter(x,
                y,
                z,
                marker='o',
                s=50,
                c=data,
                alpha=1,
                vmin=0,
                vmax=1,
                cmap="viridis")
plt.colorbar(sc)
ax.set_xlabel('$X$')
ax.set_ylabel('$Y$')
ax.view_init(30, 60)

plt.show()

# %%
